<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ViewCube - Three.js Example</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; overflow: hidden; }
    #container { width: 100vw; height: 100vh; position: relative; }
    #info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
    }
    #info h3 { margin-bottom: 10px; }
    #info p { margin: 5px 0; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="info">
    <h3>ViewCube Demo</h3>
    <p>üñ±Ô∏è Click cube faces to navigate</p>
    <p>üîÑ Drag cube to rotate scene</p>
    <p>‚ö° Drag main view with mouse</p>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ViewCube, FACES } from '../src/index.js';

    // Setup scene
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    // Create demo objects
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x4a90d9,
      metalness: 0.3,
      roughness: 0.7
    });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // Grid helper
    const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    scene.add(gridHelper);

    // Axis helper
    const axesHelper = new THREE.AxesHelper(3);
    scene.add(axesHelper);

    // Create ViewCube (Y-up for standard Three.js)
    const viewCube = new ViewCube({
      container: container,
      coordinateSystem: 'Y-up',
      size: 120,
      position: 'top-right',
      cameraDistance: 8,
      colors: {
        main: 0xe0e0e0,
        hover: 0x87CEEB,
        outline: 0x555555
      }
    });

    // Handle face clicks - animate camera
    viewCube.on('faceClick', (faceId, config) => {
      console.log('Navigate to:', faceId, config);
      
      // Animate camera to new position
      const startPos = camera.position.clone();
      const startUp = camera.up.clone();
      const targetPos = new THREE.Vector3(config.position.x, config.position.y, config.position.z);
      const targetUp = new THREE.Vector3(config.up.x, config.up.y, config.up.z);
      
      const duration = 500;
      const startTime = performance.now();
      
      function animateCamera() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5 
          ? 4 * progress * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;
        
        camera.position.lerpVectors(startPos, targetPos, eased);
        camera.up.lerpVectors(startUp, targetUp, eased).normalize();
        camera.lookAt(0, 0, 0);
        controls.update();
        
        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        }
      }
      
      animateCamera();
    });

    // Handle drag rotation - use world-axis rotation to avoid pole singularity
    viewCube.on('drag', (deltaX, deltaY) => {
      const rotationSpeed = 0.005;
      const target = new THREE.Vector3(0, 0, 0);
      
      // Get the offset from target
      const offset = camera.position.clone().sub(target);
      const distance = offset.length();
      
      // Get view direction (from camera to target)
      const viewDir = offset.clone().normalize().negate();
      
      // Calculate right vector from cross product of view direction and world up
      // This works correctly at all angles including poles
      const worldUp = new THREE.Vector3(0, 1, 0);
      let right = new THREE.Vector3().crossVectors(viewDir, worldUp);
      
      // Handle pole case: when looking straight up or down, right vector is zero
      if (right.lengthSq() < 0.001) {
        // Use camera's last known right direction or fallback
        right.set(1, 0, 0);
      } else {
        right.normalize();
      }
      
      // Rotate around world Y-axis for horizontal movement
      const rotY = new THREE.Quaternion().setFromAxisAngle(worldUp, -deltaX * rotationSpeed);
      offset.applyQuaternion(rotY);
      
      // Rotate around the right axis for vertical movement
      const rotX = new THREE.Quaternion().setFromAxisAngle(right, -deltaY * rotationSpeed);
      offset.applyQuaternion(rotX);
      
      // Apply new position, maintaining distance
      offset.normalize().multiplyScalar(distance);
      camera.position.copy(target).add(offset);
      camera.lookAt(target);
      controls.update();
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      controls.update();
      viewCube.update(camera);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
